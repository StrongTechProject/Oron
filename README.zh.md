<p align="right">
  <a href="./README.md">English</a> | 中文
</p>



# Oron Framework



**面向“无限上下文”开发的双实体软件工程框架。**

> **设计哲学：** “二元分治 + 原子化派发 + 工具桥接”。

Oron 是一个有着严格定义的架构体系，旨在解决 LLM（大语言模型）在复杂软件工程中面临的四大物理瓶颈：**上下文衰减 (Context Decay)**、**上下文真空 (Context Air-Gap)**、**交互疲劳 (IO Fatigue)** 以及 **输出过载 (Output Overload)**。它将“大脑”（Conductor）与“手脚”（Worker）物理分离，并通过本地 Python 适配器进行连接。

------



## 1. 项目定位



Oron 不仅仅是一段提示词，它是基于 **架构定义说明书 (ADD v1.0.1)** 构建的分层开发框架。它解决了单智能体编码的核心局限：随着对话轮数增加，模型智商直线下降。

Oron 采用 **状态机驱动 (State-Machine-Driven)** 的工作流：

1. **Conductor (大脑):** 维护项目状态、依赖图谱和逻辑规划。它 **绝不** 编写具体实现代码。
2. **Worker (手脚):** 在无状态环境中执行具体的、原子化的编码任务。
3. **Adapter (中间件):** 自动化处理上下文提取和提示词注入，消除繁琐的人工操作。

------



## 2. 痛点解决与效果对比



在标准 LLM 交互中，随着项目复杂度提升，模型表现会迅速劣化。Oron 引入了 **WGC (Worker 粒度控制协议)** 来确保输出质量始终如一。



### Oron 解决的核心痛点



| **痛点**       | **普通 LLM 生成模式**                                        | **Oron 架构模式**                                            |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **上下文衰减** | 随着聊天记录变长，模型忘记早期需求并开始产生幻觉。           | **已解决:** Worker 是无状态的，每轮都是全新的。仅注入当前任务相关的上下文。 |
| **输出过载**   | 一次性生成 300+ 行代码会导致“偷懒式编码”（如 `# ... 现有代码 ...`）。 | **通过 WGC 解决:** 强制执行“原子化派发”。将任务拆解为微步骤（单次 <150 行）。 |
| **上下文真空** | 架构师需要阅读每一行代码，浪费大量 Token 预算。              | **已解决:** Conductor 仅存储“接口签名” (Signatures)；Worker 处理具体实现。 |
| **交互疲劳**   | 手工在编辑器和浏览器之间复制粘贴文件内容极其耗时。           | **已解决:** `oron.py` 自动完成文件读取、格式化和剪贴板注入。 |



### 性能预估 (对比)



*对比场景：实现一个复杂的业务功能模块。*

| **指标**         | **普通对话流**          | **Oron 框架流** | **效果**           |
| ---------------- | ----------------------- | --------------- | ------------------ |
| **上下文清晰度** | 4k token 后开始衰减     | **恒定 (100%)** | 🟢 无幻觉漂移       |
| **代码可用性**   | ~60% (需人工修补)       | **~95%**        | 🟢 得益于原子化聚焦 |
| **Token 利用率** | 低 (重复读取全量文件)   | **高**          | 🟢 精准切片注入     |
| **项目生命周期** | 完成 1-2 个功能后需重置 | **无限**        | 🟢 模块化状态机     |

------



## 3. 系统架构



本系统遵循严格的“三层拓扑结构”：

代码段

```
graph TD
    User((开发者))
    
    subgraph Layer_2_Core ["Layer 2: 核心层 (Conductor)"]
        State[状态机 (YAML)]
        Plan[规划与逻辑]
    end
    
    subgraph Layer_3_Adapter ["Layer 3: 适配层 (本地)"]
        OronPy["oron.py 脚本"]
        IO[文件系统 I/O]
    end
    
    subgraph Worker_Scope ["无状态 Worker"]
        Exec[代码生成]
    end

    User -->|提示| Plan
    Plan -->|生成 CLI 命令| User
    User -->|运行命令| OronPy
    OronPy -->|读取上下文| IO
    OronPy -->|注入上下文 + 任务| Exec
    Exec -->|返回代码| User
    User -->|验证并更新| State
```

1. **Layer 1 (内核):** 宪法（规则与物理约束）。
2. **Layer 2 (核心):** 系统提示词（Conductor 智能体）。
3. **Layer 3 (适配器):** `oron.py` 脚本（负责 I/O 和 WGC 执行）。

------



## 4. 安装与使用



Oron 需要一个轻量级的本地适配器来处理文件操作和剪贴板管理。



### 环境要求



- Python 3.x
- `pyperclip` (用于剪贴板自动化)



### 安装步骤



1. 克隆本仓库或手动创建脚本文件。

2. 安装依赖库：

   Bash

   ```
   pip install pyperclip
   ```

3. 确保 `oron.py` 位于你的项目根目录下。



### CLI 使用说明



Conductor 会自动为你生成这些命令，但理解其语法有助于更好地使用。

**语法:**

Bash

```
python oron.py inject --files "<文件列表>" --task "<指令>"
```

**参数:**

- `--files`: 逗号分隔的文件路径列表 (例如 `app/main.py,app/utils.py`)。
  - *注意:* 如果文件不存在，Oron v1.0.1 会触发 **创建模式 (Creation Mode)** 进行软容错，而不是报错退出。
- `--task`: 给 Worker 的简明扼要的任务指令。

------



## 5. 快速开始 (1分钟上手指南)



遵循 ADD 文档中定义的 **Step 0-2** 流程。



### Step 0: 环境准备



将 `oron.py` 下载到你的项目文件夹中。

Bash

```
pip install pyperclip
```



### Step 1: 激活 Conductor (大脑)



1. 打开一个 LLM 会话（推荐 Claude 3.5 Sonnet 或 GPT-4o）。
2. 复制 `prompts/core_spell.md` 中的 **Core Spell v1.0.1** (初始化咒语)。
3. 粘贴到对话框中。
4. 告知项目目标：*“我想用 Python 写一个贪吃蛇游戏。”*



### Step 2: 循环作业 (The Loop)



1. **接收指令:** Conductor 会输出如下命令：

   Bash

   ```
   python oron.py inject --files "game.py" --task "初始化 Pygame 窗口和游戏主循环。"
   ```

2. **执行适配器:** 将该命令粘贴到你的终端运行。

   - *结果:* 上下文代码和任务指令已自动复制到你的剪贴板。

3. **派发给 Worker:** 打开一个 **新的/独立的** LLM 窗口（Worker），按下 `Ctrl+V` (粘贴)。

4. **同步与验证:** 将 Worker 生成的代码复制回本地文件。

5. **汇报:** 告诉 Conductor：*“VERIFIED”*（已验证）或 *“FAILED: <错误信息>”*。

------



## 6. 核心特性与关键技术解析





### ⚡ WGC (Worker 粒度控制协议)



v1.0.1 版本引入的核心机制，用于防止“上下文溢出”。Conductor 必须严格遵守 **三原则 (Rule of Three)**：

- 单次最多触碰 **3 个文件**。
- 单次仅实现 **1 个核心逻辑**。
- 单次代码输出预估不超过 **150 行**。



### 🧠 智能上下文注入 (Smart Context Injection)



`oron.py` 适配器具备上下文感知能力：

- **读取模式 (Reading Mode):** 读取文件并附加行号，便于精确修改。
- **创建模式 (Creation Mode):** 如果文件缺失，它会抑制错误报错，直接提示 Worker 从零开始创建。



### 🛡️ 接口签名防腐层 (Interface Signature ACL)



Conductor 在其 YAML 状态机（内存）中只保存 **函数签名**（例如 `def connect_db(url) -> bool`），丢弃具体的实现细节。这既节省了宝贵的上下文窗口，又保持了架构视图的清晰。



### 🔄 裂变判定 (Fission Check)



在发出指令前，Conductor 会执行“裂变判定”。如果一个任务过于复杂，它会将 Step 自动拆解为 `Task 1.1`, `Task 1.2`，确保 Worker 永远不会因为任务过重而崩溃。

------

*Copyright © 2025 Oron Project. Defined by ADD v1.0.1.*